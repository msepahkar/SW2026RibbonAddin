diff -ruN /mnt/data/SW2026RibbonAddin_base/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Algorithms.cs /mnt/data/SW2026RibbonAddin_mod/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Algorithms.cs
--- /mnt/data/SW2026RibbonAddin_base/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Algorithms.cs	2025-12-24 17:20:42.000000000 +0000
+++ /mnt/data/SW2026RibbonAddin_mod/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Algorithms.cs	2025-12-25 06:46:17.993352445 +0000
@@ -73,10 +73,10 @@
         {
             progress.ThrowIfCancelled();
 
-            // Width-first packing:
-            // Pack rectangles in horizontal shelves (rows) from left->right, bottom->top.
-            // This tends to keep the remaining unused part of the sheet as a full-width strip
-            // so it can be reused later for other jobs.
+            // Y-axis-first packing (requested):
+            // Pack rectangles in vertical shelves (columns) from bottom->top, left->right.
+            // This tends to keep the remaining unused part of the sheet as a full-height strip,
+            // so when a sheet is half-filled the empty area is a large contiguous region.
 
             double placementMargin = marginMm + gapMm;
 
@@ -91,7 +91,7 @@
             double maxY = sheetHmm - placementMargin;
 
             var remaining = ExpandInstances(defs);
-            // Start with larger parts first, then fill gaps within each row.
+            // Start with larger parts first, then fill gaps within each column.
             remaining.Sort((a, b) => (b.Width * b.Height).CompareTo(a.Width * a.Height));
 
             var sheets = new List<SheetRectState>();
@@ -111,8 +111,8 @@
                 return s;
             }
 
-            bool TryChooseForNewShelf(PartDefinition part, double availW, double availH,
-                                      out double usedW, out double usedH, out double rotRad)
+            bool TryChooseForNewColumn(PartDefinition part, double availW, double availH,
+                                       out double usedW, out double usedH, out double rotRad)
             {
                 // usedW/usedH include the gap.
                 usedW = 0;
@@ -133,15 +133,15 @@
 
                 if (fit0 && fit90)
                 {
-                    // Prefer the orientation with smaller shelf height.
-                    if (h90 < h0 - 1e-9)
+                    // Prefer the orientation with smaller column width.
+                    if (w90 < w0 - 1e-9)
                     {
                         usedW = w90;
                         usedH = h90;
                         rotRad = Math.PI / 2.0;
                         return true;
                     }
-                    if (h0 < h90 - 1e-9)
+                    if (w0 < w90 - 1e-9)
                     {
                         usedW = w0;
                         usedH = h0;
@@ -149,8 +149,8 @@
                         return true;
                     }
 
-                    // Same height: prefer larger width (helps fill width).
-                    if (w90 > w0)
+                    // Same width: prefer larger height (helps fill the column).
+                    if (h90 > h0)
                     {
                         usedW = w90;
                         usedH = h90;
@@ -180,8 +180,8 @@
                 return true;
             }
 
-            bool TryChooseForExistingShelf(PartDefinition part, double availW, double shelfH,
-                                           out double usedW, out double usedH, out double rotRad)
+            bool TryChooseForExistingColumn(PartDefinition part, double colW, double availH,
+                                            out double usedW, out double usedH, out double rotRad)
             {
                 usedW = 0;
                 usedH = 0;
@@ -193,9 +193,9 @@
                 // 0 deg
                 double w0 = part.Width + gapMm;
                 double h0 = part.Height + gapMm;
-                if (w0 <= availW && h0 <= shelfH)
+                if (w0 <= colW && h0 <= availH)
                 {
-                    double leftover = availW - w0;
+                    double leftover = availH - h0;
                     bestLeftover = leftover;
                     usedW = w0;
                     usedH = h0;
@@ -206,10 +206,10 @@
                 // 90 deg
                 double w90 = part.Height + gapMm;
                 double h90 = part.Width + gapMm;
-                if (w90 <= availW && h90 <= shelfH)
+                if (w90 <= colW && h90 <= availH)
                 {
-                    double leftover = availW - w90;
-                    if (!found || leftover < bestLeftover - 1e-9 || (Math.Abs(leftover - bestLeftover) < 1e-9 && w90 > usedW))
+                    double leftover = availH - h90;
+                    if (!found || leftover < bestLeftover - 1e-9 || (Math.Abs(leftover - bestLeftover) < 1e-9 && h90 > usedH))
                     {
                         bestLeftover = leftover;
                         usedW = w90;
@@ -269,25 +269,25 @@
             {
                 progress.ThrowIfCancelled();
 
-                double shelfY = minY;
+                double colX = minX;
                 bool placedAnything = false;
 
                 while (remaining.Count > 0)
                 {
                     progress.ThrowIfCancelled();
 
-                    double availH = maxY - shelfY;
-                    if (availH <= 1e-6)
+                    double availW = maxX - colX;
+                    if (availW <= 1e-6)
                         break;
 
-                    // Start a new shelf: take the first (largest-first) remaining part that fits.
+                    // Start a new column: take the first (largest-first) remaining part that fits.
                     int startIndex = -1;
                     double startUsedW = 0, startUsedH = 0, startRot = 0;
 
                     for (int i = 0; i < remaining.Count; i++)
                     {
                         var p = remaining[i];
-                        if (TryChooseForNewShelf(p, usableW, availH, out var uW, out var uH, out var r))
+                        if (TryChooseForNewColumn(p, availW, usableH, out var uW, out var uH, out var r))
                         {
                             startIndex = i;
                             startUsedW = uW;
@@ -303,41 +303,41 @@
                     var startPart = remaining[startIndex];
                     remaining.RemoveAt(startIndex);
 
-                    double shelfX = minX;
-                    double shelfH = startUsedH;
+                    double colY = minY;
+                    double colW = startUsedW;
 
-                    PlaceAt(cur, startPart, shelfX, shelfY, startRot);
+                    PlaceAt(cur, startPart, colX, colY, startRot);
                     placedAnything = true;
 
-                    shelfX += startUsedW;
+                    colY += startUsedH;
 
                     placedParts += Math.Max(1, startPart.PartCountWeight);
                     progress.ReportPlaced(placedParts, totalInstances, sheets.Count);
 
-                    // Fill the shelf: pick the best fit part for remaining width.
+                    // Fill the column: pick the best fit part for remaining height.
                     while (remaining.Count > 0)
                     {
                         progress.ThrowIfCancelled();
 
-                        double availW = maxX - shelfX;
-                        if (availW <= 1e-6)
+                        double availH = maxY - colY;
+                        if (availH <= 1e-6)
                             break;
 
                         int bestIdx = -1;
-                        double bestUsedW = 0, bestRot = 0;
+                        double bestUsedH = 0, bestRot = 0;
                         double bestLeftover = double.PositiveInfinity;
 
                         for (int i = 0; i < remaining.Count; i++)
                         {
                             var p = remaining[i];
-                            if (!TryChooseForExistingShelf(p, availW, shelfH, out var uW, out var uH, out var r))
+                            if (!TryChooseForExistingColumn(p, colW, availH, out var uW, out var uH, out var r))
                                 continue;
 
-                            double leftover = availW - uW;
-                            if (bestIdx < 0 || leftover < bestLeftover - 1e-9 || (Math.Abs(leftover - bestLeftover) < 1e-9 && uW > bestUsedW))
+                            double leftover = availH - uH;
+                            if (bestIdx < 0 || leftover < bestLeftover - 1e-9 || (Math.Abs(leftover - bestLeftover) < 1e-9 && uH > bestUsedH))
                             {
                                 bestIdx = i;
-                                bestUsedW = uW;
+                                bestUsedH = uH;
                                 bestRot = r;
                                 bestLeftover = leftover;
                             }
@@ -353,14 +353,14 @@
                         var pBest = remaining[bestIdx];
                         remaining.RemoveAt(bestIdx);
 
-                        PlaceAt(cur, pBest, shelfX, shelfY, bestRot);
-                        shelfX += bestUsedW;
+                        PlaceAt(cur, pBest, colX, colY, bestRot);
+                        colY += bestUsedH;
 
                         placedParts += Math.Max(1, pBest.PartCountWeight);
                         progress.ReportPlaced(placedParts, totalInstances, sheets.Count);
                     }
 
-                    shelfY += shelfH;
+                    colX += colW;
                 }
 
                 if (remaining.Count == 0)
@@ -372,7 +372,7 @@
                     bool canFitAny = false;
                     foreach (var p in remaining)
                     {
-                        if (TryChooseForNewShelf(p, usableW, usableH, out _, out _, out _))
+                        if (TryChooseForNewColumn(p, usableW, usableH, out _, out _, out _))
                         {
                             canFitAny = true;
                             break;
@@ -612,7 +612,7 @@
         {
             placement = default;
 
-            foreach (int rotDeg in RotationsDeg)
+            foreach (int rotDeg in GetRotationCandidatesDeg(part))
             {
                 progress.ThrowIfCancelled();
 
@@ -700,14 +700,31 @@
             var xs = xSet.OrderBy(v => v).Take(140).ToList();
             var ys = ySet.OrderBy(v => v).Take(140).ToList();
 
-            foreach (var y in ys)
+            // Candidate ordering depends on the default sheet fill axis.
+            // Y-axis fill => prioritize smaller X first (columns), then stack upward.
+            if (DEFAULT_SHEET_FILL_AXIS == SheetFillAxis.Y)
             {
                 foreach (var x in xs)
                 {
-                    Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                    foreach (var y in ys)
+                    {
+                        Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                        if (result.Count >= maxCandidates) break;
+                    }
+                    if (result.Count >= maxCandidates) break;
+                }
+            }
+            else
+            {
+                foreach (var y in ys)
+                {
+                    foreach (var x in xs)
+                    {
+                        Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                        if (result.Count >= maxCandidates) break;
+                    }
                     if (result.Count >= maxCandidates) break;
                 }
-                if (result.Count >= maxCandidates) break;
             }
 
             if (result.Count < maxCandidates && sheet.Placed.Count > 0)
@@ -959,7 +976,7 @@
         {
             placement = default;
 
-            foreach (int rotDeg in RotationsDeg)
+            foreach (int rotDeg in GetRotationCandidatesDeg(part))
             {
                 progress.ThrowIfCancelled();
                 ThrowIfDeadlineExceeded(deadlineTicks);
@@ -1062,14 +1079,30 @@
 
                 int skylineBudget = Math.Min(250, maxCandidates / 2);
 
-                foreach (var y in ys)
+                // Candidate ordering depends on the default sheet fill axis.
+                if (DEFAULT_SHEET_FILL_AXIS == SheetFillAxis.Y)
                 {
                     foreach (var x in xs)
                     {
-                        Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                        foreach (var y in ys)
+                        {
+                            Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                            if (result.Count >= skylineBudget) break;
+                        }
+                        if (result.Count >= skylineBudget) break;
+                    }
+                }
+                else
+                {
+                    foreach (var y in ys)
+                    {
+                        foreach (var x in xs)
+                        {
+                            Add(x - rp.OffsetBounds.MinX, y - rp.OffsetBounds.MinY);
+                            if (result.Count >= skylineBudget) break;
+                        }
                         if (result.Count >= skylineBudget) break;
                     }
-                    if (result.Count >= skylineBudget) break;
                 }
             }
 
@@ -1157,6 +1190,239 @@
             return areaB.CompareTo(areaA);
         }
 
+        private static int[] GetRotationCandidatesDeg(PartDefinition part)
+        {
+            if (part == null)
+                return DefaultRotationsDeg;
+
+            var cached = part.RotationCandidatesDeg;
+            if (cached != null && cached.Length > 0)
+                return cached;
+
+            part.RotationCandidatesDeg = BuildRotationCandidatesDeg(part);
+            return part.RotationCandidatesDeg ?? DefaultRotationsDeg;
+        }
+
+        private static int NormalizeDeg(int deg)
+        {
+            deg %= 360;
+            if (deg < 0) deg += 360;
+            return deg;
+        }
+
+        /// <summary>
+        /// Builds an ordered list of rotation candidates (degrees) for a part.
+        /// The list always starts with the fast/stable defaults {0,90,180,270}.
+        /// Extra angles are appended only for non-orthogonal parts, and only used
+        /// when the default orientations fail to place the part.
+        /// </summary>
+        private static int[] BuildRotationCandidatesDeg(PartDefinition part)
+        {
+            Path64 poly = part?.OuterContour0;
+            if (poly == null || poly.Count < 3)
+                return DefaultRotationsDeg;
+
+            // Heuristics tuned to avoid enabling arbitrary angles for simple rectangles
+            // with tiny chamfers/fillets, while still allowing rotated/diagonal parts.
+            const double ORTHO_TOL_DEG = 2.0;
+            const double MIN_EDGE_MM = 2.0;            // ignore tiny segments (arc tessellation noise)
+            const double NONORTHO_FRAC_ENABLE = 0.15;  // perimeter fraction required to enable extra angles
+            const int EDGE_ANGLE_BIN_DEG = 3;
+            const int MAX_DOMINANT_ANGLES = 3;
+            const int MAX_ROTATIONS_TOTAL = 32;
+
+            double minEdgeScaled = MIN_EDGE_MM * SCALE;
+
+            double totalLen = 0.0;
+            double orthoLen = 0.0;
+            double nonOrthoLen = 0.0;
+
+            var bins = new Dictionary<int, double>(); // angle bin (0..179) -> length weight
+
+            int n = poly.Count;
+            for (int i = 0; i < n; i++)
+            {
+                var a = poly[i];
+                var b = poly[(i + 1) % n];
+
+                double dx = (double)(b.X - a.X);
+                double dy = (double)(b.Y - a.Y);
+                double len = Math.Sqrt(dx * dx + dy * dy);
+                if (len < minEdgeScaled)
+                    continue;
+
+                totalLen += len;
+
+                double ang = Math.Atan2(dy, dx) * 180.0 / Math.PI;
+
+                // Undirected edge angle in [0,180).
+                while (ang < 0.0) ang += 180.0;
+                while (ang >= 180.0) ang -= 180.0;
+
+                double mod = ang % 90.0;
+                double dev = Math.Min(mod, 90.0 - mod);
+
+                if (dev <= ORTHO_TOL_DEG)
+                {
+                    orthoLen += len;
+                    continue;
+                }
+
+                nonOrthoLen += len;
+
+                int bin = (int)Math.Round(ang / EDGE_ANGLE_BIN_DEG) * EDGE_ANGLE_BIN_DEG;
+                bin = ((bin % 180) + 180) % 180;
+                if (bins.TryGetValue(bin, out var w))
+                    bins[bin] = w + len;
+                else
+                    bins[bin] = len;
+            }
+
+            if (totalLen <= 0.0)
+                return DefaultRotationsDeg;
+
+            double nonOrthoFrac = nonOrthoLen / totalLen;
+            if (nonOrthoFrac < NONORTHO_FRAC_ENABLE)
+                return DefaultRotationsDeg;
+
+            // defaults first, then extras
+            var used = new HashSet<int>(DefaultRotationsDeg);
+            var extras = new List<int>(16);
+
+            void AddRot(int deg)
+            {
+                deg = NormalizeDeg(deg);
+                if (used.Add(deg))
+                    extras.Add(deg);
+            }
+
+            // 1) Principal axis (PCA): helps for elongated parts with rounded edges.
+            if (TryGetPrincipalAxisDeg(poly, out double axisDeg, out double anisotropy) && anisotropy >= 0.15)
+            {
+                double mod = axisDeg % 90.0;
+                double dev = Math.Min(mod, 90.0 - mod);
+                if (dev > ORTHO_TOL_DEG)
+                {
+                    int r0 = (int)Math.Round(-axisDeg);
+                    int r90 = (int)Math.Round(90.0 - axisDeg);
+                    AddRot(r0);
+                    AddRot(r0 + 180);
+                    AddRot(r90);
+                    AddRot(r90 + 180);
+                }
+            }
+
+            // 2) Dominant non-orth edge directions.
+            if (bins.Count > 0)
+            {
+                var top = bins.OrderByDescending(kv => kv.Value).Take(MAX_DOMINANT_ANGLES).ToList();
+                foreach (var kv in top)
+                {
+                    int ang = kv.Key;
+                    int r0 = -ang;
+                    int r90 = 90 - ang;
+                    AddRot(r0);
+                    AddRot(r0 + 180);
+                    AddRot(r90);
+                    AddRot(r90 + 180);
+                }
+            }
+
+            // 3) Coarse grid fallback (only reached if defaults + (1)/(2) fail).
+            // This is useful for truly "arbitrary" parts where the best fit angle is not obvious.
+            if (extras.Count < 6)
+            {
+                for (int d = 0; d < 360; d += 30)
+                {
+                    if (d % 90 == 0) continue;
+                    AddRot(d);
+                }
+            }
+
+            // 4) Finer grid only for strongly non-orth parts.
+            if (nonOrthoFrac >= 0.50 && extras.Count < 12)
+            {
+                for (int d = 0; d < 360; d += 15)
+                {
+                    if (d % 90 == 0) continue;
+                    AddRot(d);
+                    if (DefaultRotationsDeg.Length + extras.Count >= MAX_ROTATIONS_TOTAL)
+                        break;
+                }
+            }
+
+            if (extras.Count == 0)
+                return DefaultRotationsDeg;
+
+            int total = Math.Min(MAX_ROTATIONS_TOTAL, DefaultRotationsDeg.Length + extras.Count);
+            var res = new int[total];
+            Array.Copy(DefaultRotationsDeg, res, DefaultRotationsDeg.Length);
+
+            int outIdx = DefaultRotationsDeg.Length;
+            for (int i = 0; i < extras.Count && outIdx < total; i++)
+                res[outIdx++] = extras[i];
+
+            return res;
+        }
+
+        // Principal component (PCA) axis of a polygon point set.
+        // Returns axisDeg in [0,180) and anisotropy in [0,1].
+        private static bool TryGetPrincipalAxisDeg(Path64 poly, out double axisDeg, out double anisotropy)
+        {
+            axisDeg = 0.0;
+            anisotropy = 0.0;
+
+            if (poly == null || poly.Count < 3)
+                return false;
+
+            int n = poly.Count;
+
+            double meanX = 0.0, meanY = 0.0;
+            for (int i = 0; i < n; i++)
+            {
+                meanX += poly[i].X;
+                meanY += poly[i].Y;
+            }
+
+            meanX /= n;
+            meanY /= n;
+
+            double cxx = 0.0, cyy = 0.0, cxy = 0.0;
+            for (int i = 0; i < n; i++)
+            {
+                double x = poly[i].X - meanX;
+                double y = poly[i].Y - meanY;
+                cxx += x * x;
+                cyy += y * y;
+                cxy += x * y;
+            }
+
+            if (n > 1)
+            {
+                cxx /= (n - 1);
+                cyy /= (n - 1);
+                cxy /= (n - 1);
+            }
+
+            double trace = cxx + cyy;
+            if (trace <= 0.0)
+                return false;
+
+            double diff = cxx - cyy;
+            double root = Math.Sqrt(diff * diff + 4.0 * cxy * cxy);
+            double lambda1 = (trace + root) / 2.0;
+            double lambda2 = (trace - root) / 2.0;
+
+            anisotropy = (lambda1 - lambda2) / (lambda1 + lambda2 + 1e-12);
+
+            double angleRad = 0.5 * Math.Atan2(2.0 * cxy, diff);
+            double deg = angleRad * 180.0 / Math.PI;
+            while (deg < 0.0) deg += 180.0;
+            while (deg >= 180.0) deg -= 180.0;
+            axisDeg = deg;
+            return true;
+        }
+
         private static RotatedPoly GetOrCreateRotated(PartDefinition part, int rotDeg, double gapMm, Dictionary<string, RotatedPoly> cache)
         {
             string key =
@@ -1210,14 +1476,26 @@
 
         private static int CandidateCompare(CandidateIns a, CandidateIns b, RotatedPoly rp)
         {
+            long aMinX = a.InsX + rp.OffsetBounds.MinX;
+            long bMinX = b.InsX + rp.OffsetBounds.MinX;
             long aMinY = a.InsY + rp.OffsetBounds.MinY;
             long bMinY = b.InsY + rp.OffsetBounds.MinY;
-            int cmp = aMinY.CompareTo(bMinY);
-            if (cmp != 0) return cmp;
 
-            long aMinX = a.InsX + rp.OffsetBounds.MinX;
-            long bMinX = b.InsX + rp.OffsetBounds.MinX;
-            return aMinX.CompareTo(bMinX);
+            // Candidate priority depends on the requested default fill axis:
+            // - Y-axis fill => build "columns": smaller X first, then smaller Y
+            // - X-axis fill => build "rows"   : smaller Y first, then smaller X
+            if (DEFAULT_SHEET_FILL_AXIS == SheetFillAxis.Y)
+            {
+                int cmp = aMinX.CompareTo(bMinX);
+                if (cmp != 0) return cmp;
+                return aMinY.CompareTo(bMinY);
+            }
+            else
+            {
+                int cmp = aMinY.CompareTo(bMinY);
+                if (cmp != 0) return cmp;
+                return aMinX.CompareTo(bMinX);
+            }
         }
 
         private static bool CandidateFits(CandidateIns cand, RotatedPoly rp, long usableW, long usableH, out LongRect movedBBox)
diff -ruN /mnt/data/SW2026RibbonAddin_base/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Core.cs /mnt/data/SW2026RibbonAddin_mod/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Core.cs
--- /mnt/data/SW2026RibbonAddin_base/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Core.cs	2025-12-25 05:53:07.000000000 +0000
+++ /mnt/data/SW2026RibbonAddin_mod/SW2026RibbonAddin-master/Commands/dwg/DwgLaserNester.Core.cs	2025-12-25 06:41:21.696008686 +0000
@@ -19,7 +19,15 @@
     {
         // Geometry scale for Clipper (mm -> integer)
         private const long SCALE = 1000; // 0.001 mm units
-        private static readonly int[] RotationsDeg = { 0, 90, 180, 270 };
+
+        // Default rotation set (fast + stable). Extra angles may be appended per-part when needed.
+        private static readonly int[] DefaultRotationsDeg = { 0, 90, 180, 270 };
+
+        // Default sheet fill axis (requested): fill along Y.
+        // In practice this means we prioritize placements with smaller X first (columns),
+        // so the remaining space stays as a large contiguous strip.
+        private enum SheetFillAxis { X = 0, Y = 1 }
+        private const SheetFillAxis DEFAULT_SHEET_FILL_AXIS = SheetFillAxis.Y;
 
         // ============================
         // DWG output styling (layers/blocks)
@@ -434,6 +442,10 @@
 
             public Path64 OuterContour0;
             public long OuterArea2Abs;
+
+            // Rotation candidates for contour nesting (computed lazily).
+            // Default is {0,90,180,270}; extra angles are appended only when needed.
+            public int[] RotationCandidatesDeg;
         }
 
         /// <summary>
